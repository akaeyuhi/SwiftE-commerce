import { DeepPartial, ObjectLiteral, Repository } from 'typeorm';
import { NotFoundException } from '@nestjs/common';

/**
 * BaseRepository
 *
 * Small reusable abstract repository that extends TypeORM's `Repository<T>`
 * and provides common CRUD helper methods used across the app.
 *
 * Subclasses should extend this repository using TypeORM's custom repository
 * pattern (e.g., `DataSource.getRepository(MyEntity).extend(BaseRepository)` or
 * by using `@EntityRepository` / custom provider depending on your TypeORM version).
 *
 * Generics:
 * - `Entity` — TypeORM entity type (must extend `ObjectLiteral`).
 *
 * Notes:
 * - Methods in this base class are convenience wrappers around TypeORM repository
 *   methods. They do not perform transaction handling — if you need atomic multi-step
 *   operations, wrap calls in a transaction at the service layer.
 * - `updateEntity` currently returns the entity as fetched *before* the update is applied.
 *   If you want the updated entity returned, call `this.findById(id)` again after `this.update(...)`
 *   or change the implementation to fetch & return the updated row.
 */
export abstract class BaseRepository<
  Entity extends ObjectLiteral,
> extends Repository<Entity> {
  /**
   * Find all entities.
   *
   * Simple wrapper for `this.find()`.
   *
   * @returns Promise resolving to an array of all entities (possibly empty).
   */
  async findAll(): Promise<Entity[]> {
    return this.find();
  }

  /**
   * Find entity by id.
   *
   * Wrapper for `findOneBy({ id })`. Returns `null` if not found.
   *
   * @param id - entity identifier (string)
   * @returns Promise resolving to the found entity or `null` if not present
   */
  async findById(id: string): Promise<Entity | null> {
    return this.findOneBy({ id } as any);
  }

  /**
   * Delete entity by id.
   *
   * Wrapper for `this.delete(id)`. Note:
   * - If you use soft deletes in your project, replace this with `softDelete` or
   *   override in subclass.
   * - TypeORM's `delete` does not throw if the row does not exist; it will silently succeed.
   *
   * @param id - entity identifier to delete
   * @returns Promise that resolves when the delete completes
   */
  async deleteById(id: string): Promise<void> {
    await this.delete(id);
  }

  /**
   * Create and persist a new entity.
   *
   * This method:
   * 1. calls `this.create(data)` to create a new entity instance,
   * 2. calls `this.save(entity)` to persist it.
   *
   * The `data` parameter accepts partial data (DeepPartial) — useful for
   * cases where some fields are filled by the database (e.g., autogenerated ids).
   *
   * @param data - partial entity data used to create the entity
   * @returns Promise resolving to the saved entity (with generated columns populated)
   */
  async createEntity(data: DeepPartial<Entity>): Promise<Entity> {
    const entity = this.create(data);
    return await this.save(entity);
  }

  /**
   * Update an entity by id.
   *
   * Current behavior:
   *  - It first attempts to fetch the entity via `findById`.
   *  - If not found, throws `NotFoundException`.
   *  - Calls `this.update(id, data)` to apply changes.
   *  - Returns the entity instance fetched before the update (not the updated one).
   *
   * Important notes:
   *  - Because this returns the pre-update entity, callers expecting the updated row
   *    should either:
   *     a) call `await repo.updateEntity(id, data); return repo.findById(id);` in the service,
   *     b) or modify this method to `await this.update(id, data); return this.findById(id);`
   *  - Update is executed via `this.update` which issues a direct UPDATE SQL. If you need
   *    entity lifecycle hooks or to run validations, consider loading the entity, applying
   *    changes on the entity object, and saving with `this.save(entity)`.
   *
   * @param id - identifier of the entity to update
   * @param data - partial entity fields to update
   * @throws NotFoundException if entity with provided id does not exist
   * @returns Promise resolving to the (pre-update) entity instance
   */
  async updateEntity(id: string, data: Partial<Entity>): Promise<Entity> {
    const admin = await this.findById(id);
    if (!admin) {
      throw new NotFoundException(`Entity with ID ${id} not found`);
    }
    await this.update(id, data);
    return admin;
  }
}

/**
 * Example usage:
 *
 * // Suppose you have an entity `UserEntity`.
 * class UserRepository extends BaseRepository<UserEntity> {}
 *
 * // In a service:
 * const users = await userRepository.findAll();
 * const created = await userRepository.createEntity({ name: 'Alice' });
 * await userRepository.updateEntity(created.id, { name: 'Alice Smith' });
 *
 * // If you want the updated row after updateEntity, either:
 * const pre = await userRepository.updateEntity(id, data);
 * const after = await userRepository.findById(id);
 *
 * // Or modify updateEntity to return the updated entity.
 */
